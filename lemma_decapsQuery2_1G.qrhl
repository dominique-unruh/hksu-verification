include "variables.qrhl".
include "queryG.qrhl".
include "decapsQuery2.qrhl".
include "decapsQuery2_G.qrhl".

# Must be of the same shape of decapsQuery1_1G to be usable in
# autogenerated lemmas. It's actually a rather trivial fact because
# decapsQuery2 and decapsQuery2_G differ only in one unused oracle
# query.

# GRAPH: EQ("decapsQuery2_1G","decapsQuery2","decapsQuery2_G")
qrhl decapsQuery2_1G:
  {Cla[G1=G2 & sk1=sk2 & c1=c2 & cstar1=cstar2 & K'1=K'2 & pk1=pk2 & Hq1=Hq2 & Hr1=Hr2] ⊓ ⟦quantA1,Gin1,Gout1,aux1⟧ ≡𝔮 ⟦quantA2,Gin2,Gout2,aux2⟧} 
    call decapsQuery2; ~ call decapsQuery2_G(queryG); 
  {Cla[G1=G2 & sk1=sk2 & c1=c2 & cstar1=cstar2 & K'1=K'2 & pk1=pk2 & Hq1=Hq2 & Hr1=Hr2] ⊓ ⟦quantA1,Gin1,Gout1,aux1⟧ ≡𝔮 ⟦quantA2,Gin2,Gout2,aux2⟧}.

 inline decapsQuery2.
 inline decapsQuery2_G.
 local remove right.
  simp!.

 equal mid quantA, Gin, Gout, aux.
  simp!.

  # else-branch
  wp 1 1.

  conseq pre: ℭ𝔩𝔞[c1 = c2 ∧ cstar1 = cstar2 ∧ K'1 = K'2 & G1 = G2 ∧ sk1 = sk2 ∧ pk1 = pk2 ∧ Hq1 = Hq2 ∧ Hr1 = Hr2] ⊓ ⟦quantA1, Gin1, Gout1, aux1⟧ ≡𝔮 ⟦quantA2, Gin2, Gout2, aux2⟧.
   simp!.
  conseq post: ℭ𝔩𝔞[c1 = c2 ∧ cstar1 = cstar2 ∧ K'1 = K'2 & G1 = G2 ∧ sk1 = sk2 ∧ pk1 = pk2 ∧ Hq1 = Hq2 ∧ Hr1 = Hr2] ⊓ ⟦quantA1, Gin1, Gout1, aux1⟧ ≡𝔮 ⟦quantA2, Gin2, Gout2, aux2⟧.
   simp!.
  frame.
   simp!.
  inline ClassicalQueryG.
  inline queryG.
  local up.
  local remove right.
   simp!.

  # gout
  wp right.
  conseq post: ℭ𝔩𝔞[c1 = c2 ∧ cstar1 = cstar2 ∧ K'1 = K'2 ∧ G1 = G2 ∧ sk1 = sk2 ∧ pk1 = pk2 ∧ Hq1 = Hq2 ∧ Hr1 = Hr2].
   simp!.

  wp right 5.
  skip.
  simp!.

 skip.
 simp.
qed.
