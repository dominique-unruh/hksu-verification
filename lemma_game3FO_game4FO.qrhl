include "game3FO.qrhl".
include "game4FO.qrhl".
include "axioms.qrhl".

# GRAPH: EQ("game3FO_game4FO","game3FO","game4FO",uses="Adv_INDCCA_encFO_lossless_dq2")
qrhl game3FO_game4FO: {â„­ğ”©ğ”[classA1 = classA2 âˆ§ b1 = b2 âˆ§ in_pk1 = in_pk2 âˆ§ in_cstar1 = in_cstar2] 
                       âŠ“ âŸ¦quantA1âŸ§ â‰¡ğ”® âŸ¦quantA2âŸ§}
     call game3FO; ~ call game4FO;
     {Cla[cstar1 âˆˆ (encrT G1 pk1) ` msg_spaceT G1] + Cla[b1 = b2]}.

 conseq post: Cla[cstar1 âˆˆ (encrT G1 pk1) ` msg_spaceT G1] + (Cla[b1 = b2] âŠ“ âŸ¦quantA1âŸ§ â‰¡ğ”® âŸ¦quantA2âŸ§).
  simp!.

 inline game3FO.
 inline game4FO.

 # Adv_INDCCA_encFO
 seq <-> 11 11: Cla[cstar1 âˆˆ (encrT G1 pk1) ` msg_spaceT G1] + (â„­ğ”©ğ”[cstar1 = cstar2 âˆ§ (âˆ€xâ‰ cstar1. Hq1 x = Hq2 x) âˆ§ classA1 = classA2 âˆ§ b1 = b2 âˆ§ in_pk1 = in_pk2 âˆ§ in_cstar1 = in_cstar2 âˆ§ Kstar1 = Kstar2 âˆ§ G1 = G2 âˆ§ H1 = H2] âŠ“ âŸ¦quantA1âŸ§ â‰¡ğ”® âŸ¦quantA2âŸ§).

 case bad := cstar1 âˆˆ (encrT G1 pk1) ` msg_spaceT G1.
 casesplit bad.

 # Case: bad
 conseq pre: Cla[True] âŠ“ â„­ğ”©ğ”[cstar1 âˆˆ (encrT G1 pk1) ` msg_spaceT G1].
  simp!.
 conseq post: Cla[True] âŠ“ â„­ğ”©ğ”[cstar1 âˆˆ (encrT G1 pk1) ` msg_spaceT G1].
  simp!.
 frame.
  simp!.
 seq 1 0: Cla[True].
  conseq qrhl: Adv_INDCCA_encFO_lossless_dq2.
   simp!.
   simp!.

  sym.
  conseq qrhl: Adv_INDCCA_encFO_lossless_dq2.
   simp!.
   simp!.

 # Case: Â¬ bad
 conseq post: â„­ğ”©ğ”[b1 = b2 âˆ§ cstar1=cstar2 âˆ§ (âˆ€xâ‰ cstar1. Hq1 x = Hq2 x)] âŠ“ âŸ¦quantA1âŸ§ â‰¡ğ”® âŸ¦quantA2âŸ§.
  simp!.
 
 equal exclude decapsQuery2.
  simp!.
  inline decapsQuery2.
  wp 1 1.
  skip.
  simp!.

 skip.
 simp!.

 # End of Adv_INDCCA_encFO



 # in_pk, in_cstar
 wp 2 2.
 conseq post: Cla[cstar1 âˆˆ (encrT G1 pk1) ` msg_spaceT G1] + (â„­ğ”©ğ”[cstar1 = cstar2 âˆ§ (âˆ€xâ‰ cstar1. Hq1 x = Hq2 x) âˆ§ classA1 = classA2 âˆ§ b1 = b2 âˆ§ in_pk1 = in_pk2 âˆ§ in_cstar1 = in_cstar2 âˆ§ Kstar1 = Kstar2 âˆ§ G1 = G2 âˆ§ H1 = H2 & pk1=pk2] âŠ“ âŸ¦quantA1âŸ§ â‰¡ğ”® âŸ¦quantA2âŸ§).
  simp!.

 # pk,(sk,prfk) before Hq, H0
 swap left 5-5 3-4.
 # cstar after pk,(sk,prfk)
 swap left 8-8 4-7.
 # Kstar after Hq, H0
 swap left 9-9 7-8.

 # pk,(sk,prfk) before Hq, H0
 swap right 5-5 3-4.
 # cstar after pk,(sk,prfk)
 swap right 8-8 4-7.
 # Kstar after Hq, H0
 swap right 9-9 7-8.

 # mstar
 wp 1 1.
 conseq post: Cla[cstar1 âˆˆ (encrT G1 pk1) ` msg_spaceT G1] + (â„­ğ”©ğ”[cstar1 = cstar2 âˆ§ (âˆ€xâ‰ cstar1. Hq1 x = Hq2 x) âˆ§ classA1 = classA2 âˆ§ b1 = b2 âˆ§ in_pk1 = in_pk2 âˆ§ in_cstar1 = in_cstar2 âˆ§ Kstar1 = Kstar2 âˆ§ G1 = G2 âˆ§ H1 = H2 & pk1=pk2] âŠ“ âŸ¦quantA1âŸ§ â‰¡ğ”® âŸ¦quantA2âŸ§).
  simp!.

 # H
 wp 1 1.
 conseq post: Cla[cstar1 âˆˆ (encrT G1 pk1) ` msg_spaceT G1] + (â„­ğ”©ğ”[cstar1 = cstar2 âˆ§ (âˆ€xâ‰ cstar1. Hq1 x = Hq2 x) âˆ§ classA1 = classA2 âˆ§ b1 = b2 âˆ§ in_pk1 = in_pk2 âˆ§ in_cstar1 = in_cstar2 âˆ§ Kstar1 = Kstar2 âˆ§ G1 = G2 âˆ§ pk1=pk2 & H01=H02] âŠ“ âŸ¦quantA1âŸ§ â‰¡ğ”® âŸ¦quantA2âŸ§).
  isa! auto simp: Hq1_Hq2.

 # Hq,Kstar
 squash left.
 squash right.
 rnd (Hq,Kstar),(Hq,Kstar) <- map_distr (Î»(Hq,Kstar). ((Hq(cstar1:=Kstar),Kstar),(Hq,Kstar))) (product_distr (uniform UNIV) (uniform UNIV)).
 conseq post: Cla[cstar1 âˆˆ (encrT G1 pk1) ` msg_spaceT G1] + (â„­ğ”©ğ”[cstar1 = cstar2 âˆ§ classA1 = classA2 âˆ§ b1 = b2 âˆ§ in_pk1 = in_pk2 âˆ§ in_cstar1 = in_cstar2 âˆ§ G1 = G2 âˆ§ pk1=pk2 & H01=H02] âŠ“ âŸ¦quantA1âŸ§ â‰¡ğ”® âŸ¦quantA2âŸ§).
  simp! case_prod_beta map_distr_Hq_Kstar.

 # H0
 rnd.
 # cstar
 rnd.
 # pk,(sk,prfk)
 rnd.
 # Hr
 rnd.
 # G
 rnd.
 conseq post: â„­ğ”©ğ”[classA1 = classA2 âˆ§ b1 = b2 âˆ§ in_pk1 = in_pk2 âˆ§ in_cstar1 = in_cstar2] âŠ“ âŸ¦quantA1âŸ§ â‰¡ğ”® âŸ¦quantA2âŸ§.
  simp!.

 skip.
 simp!.
qed.
