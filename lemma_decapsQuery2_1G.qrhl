include "variables.qrhl".
include "queryG.qrhl".
include "decapsQuery2.qrhl".
include "decapsQuery2_G.qrhl".

# Must be of the same shape of decapsQuery1_1G to be usable in
# autogenerated lemmas. It's actually a rather trivial fact because
# decapsQuery2 and decapsQuery2_G differ only in one unused oracle
# query.

# GRAPH: EQ("decapsQuery2_1G","decapsQuery2","decapsQuery2_G")
qrhl decapsQuery2_1G:
  {Cla[G1=G2 & sk1=sk2 & c1=c2 & cstar1=cstar2 & K'1=K'2 & pk1=pk2 & Hq1=Hq2 & Hr1=Hr2] âŠ“ âŸ¦quantA1,Gin1,Gout1,aux1âŸ§ â‰¡ğ”® âŸ¦quantA2,Gin2,Gout2,aux2âŸ§} 
    call decapsQuery2; ~ call decapsQuery2_G(queryG); 
  {Cla[G1=G2 & sk1=sk2 & c1=c2 & cstar1=cstar2 & K'1=K'2 & pk1=pk2 & Hq1=Hq2 & Hr1=Hr2] âŠ“ âŸ¦quantA1,Gin1,Gout1,aux1âŸ§ â‰¡ğ”® âŸ¦quantA2,Gin2,Gout2,aux2âŸ§}.

 inline decapsQuery2.
 inline decapsQuery2_G.
 local remove right.
  simp!.

 equal mid quantA, Gin, Gout, aux.
  simp!.

  # else-branch
  wp 1 1.

  conseq pre: â„­ğ”©ğ”[c1 = c2 âˆ§ cstar1 = cstar2 âˆ§ K'1 = K'2 & G1 = G2 âˆ§ sk1 = sk2 âˆ§ pk1 = pk2 âˆ§ Hq1 = Hq2 âˆ§ Hr1 = Hr2] âŠ“ âŸ¦quantA1, Gin1, Gout1, aux1âŸ§ â‰¡ğ”® âŸ¦quantA2, Gin2, Gout2, aux2âŸ§.
   simp!.
  conseq post: â„­ğ”©ğ”[c1 = c2 âˆ§ cstar1 = cstar2 âˆ§ K'1 = K'2 & G1 = G2 âˆ§ sk1 = sk2 âˆ§ pk1 = pk2 âˆ§ Hq1 = Hq2 âˆ§ Hr1 = Hr2] âŠ“ âŸ¦quantA1, Gin1, Gout1, aux1âŸ§ â‰¡ğ”® âŸ¦quantA2, Gin2, Gout2, aux2âŸ§.
   simp!.
  frame.
   simp!.
  inline ClassicalQueryG.
  inline queryG.
  local up.
  local remove right.
   simp!.

  # gout
  wp right.
  conseq post: â„­ğ”©ğ”[c1 = c2 âˆ§ cstar1 = cstar2 âˆ§ K'1 = K'2 âˆ§ G1 = G2 âˆ§ sk1 = sk2 âˆ§ pk1 = pk2 âˆ§ Hq1 = Hq2 âˆ§ Hr1 = Hr2].
   simp!.

  wp right 5.
  skip.
  simp!.

 skip.
 simp.
qed.
