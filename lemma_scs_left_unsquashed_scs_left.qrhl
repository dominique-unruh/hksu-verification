include "scs_left.qrhl".
include "scs_left_unsquashed.qrhl".

# GRAPH: EQ("scs_left_unsquashed_scs_left","scs_left_unsquashed","scs_left")
lemma scs_left_unsquashed_scs_left: Pr[Find:scs_left_unsquashed(rho)] = Pr[Find:scs_left(rho)].
 byqrhl.
 inline scs_left_unsquashed.
 inline scs_left.

 equal.
  simp!.
 
 conseq post: ℭ𝔩𝔞[z1 = z2 ∧ classA1 = classA2 ∧ b1 = b2 ∧ count1 = count2 ∧ S1 = S2 ∧ is_puncture1 = is_puncture2 ∧ Find1 = Find2 ∧ G1 = G2] ⊓ ⟦quantA1⟧ ≡𝔮 ⟦quantA2⟧.
  simp!.

 # Find
 wp 1 1.
 conseq post: ℭ𝔩𝔞[z1 = z2 ∧ classA1 = classA2 ∧ b1 = b2 ∧ count1 = count2 ∧ S1 = S2 ∧ is_puncture1 = is_puncture2 ∧ G1 = G2] ⊓ ⟦quantA1⟧ ≡𝔮 ⟦quantA2⟧.
  simp!.

 squash left.
 squash left.
 squash left.
 squash left.
 squash left.

 simp * scs_distr0_def_sym.

 rnd (G,(pk,sk),mstar,rstar,z,S), (S,G,z) <- 
   map_distr (λ(G,(pk,sk),mstar,rstar,z,S). ((G,(pk,sk),mstar,rstar,z,S), (S,G,z))) scs_distr0.
 conseq post: ℭ𝔩𝔞[classA1 = classA2 ∧ b1 = b2 ∧ count1 = count2 ∧ is_puncture1 = is_puncture2] ⊓ ⟦quantA1⟧ ≡𝔮 ⟦quantA2⟧.
  simp! scs_distr_def case_prod_beta_abs_def.

 # count
 wp 1 1.
 skip.
 simp! divide_tmp_Gout.
qed.
