# Autogenerated file (by replacing game0FO -> game0FO', game1FO -> game1FO', etc. etc. in lemma_game1FO_game2FO.qrhl)

# We are proving that game1FO', game2FO' are close. 

# The difference between those two: in game2FO', "if (m'=None ∨ encrT G pk (the m') ≠ c)" is
# removed, i.e., we always assume that this condition does not hold.

# The proof follows the following lines (it deviates from the AKE-paper):

# In game1FO'_goodbad, instead of picking G random, we pick functions
# Ggood and Gbad with good/bad outputs, and S as the set of inputs
# telling us which for which input which of the two functions should
# be used.  Furthermore, we rewrite the oracle decapsQuery1 to
# explicitly take an oracle for G as an argument
# (decapsQuery1_G(queryG)). Similarly, we rewrite queryH to use a
# G-oracle (queryH_Hq(queryG)). The resulting distribution of G is
# unchanged, as shown in the following file:

include "lemma_game1FO'_goodbad.qrhl".

# In order to show that picking G only with good outputs is not
# noticeable, we use the O2H theorem.  As a first step, we need to
# rewrite game1FO'_goodbad in a form suitable for the O2H theorem. This
# is done in game1FO'_goodbad_o2h_right. Here the relevant variables
# are chosen by some suitable function goodbad_o2h_distr, and then an
# adversary Adv_O2H_goodbad picks all the other variables and run the
# rest of game1FO'_goodbad. The following lemma shows that this makes no difference.

include "lemma_game1FO'_goodbad_o2h_right.qrhl".

# In game1FO'_goodbad_o2h_left, we replaced the function G chosen as in
# lemma_game1FO'_goodbad_o2h_right by G chosen only with good
# outputs. This can only be noticed if the adversary finds an element
# of S. Thus, using the O2H lemma we show that the adversary cannot
# distinguish lemma_game1FO'_goodbad_o2h_right and
# lemma_game1FO'_goodbad_o2h_left (except with small probability).

include "lemma_game1FO'_o2h_concrete.qrhl".

# game1FO'_goodbad_o2h_left' is like game1FO'_goodbad_o2h_left but
# omitting the Count oracle (the Count oracle makes the proof of
# game1FO'_game2FO'_o2h unnecessarily complicated because then count
# cannot be removed by the frame rule in the ClassicalQueryG_queryG
# use and things get confusing from there)

include "lemma_game1FO'_goodbad_o2h_left'.qrhl".

# Relative to game1FO'_goodbad_o2h_left', we unwrap Adv_O2H_Game1FO' and
# replace ClassicalQueryG(queryG) and queryH_Hq(queryG) and decapsQuery1_G(queryG)
# back by G gin, queryH, decapsQuery1.

include "lemma_game1FO'_goodbad_o2h_left_class.qrhl".

# The decapsulation query is changed: With respect to decapsQuery1: If
# bad_pk holds (and thus the definition of G is not guaranteed to
# return good randomness), we just patch the if-statement in
# decapsQuery1 to do just what we need in the next proof step.

include "lemma_game1FO'_goodbad_badpk.qrhl".

# game2FO'_goodbad_range: Contains decapsQuery2_range, like
# decapsQuery1_badpk, except that the if-guard becomes "c ∉ encrT G pk
# ` msg_space ()" instead of checking for reencryption failure. The
# fact that the randomness is good implies that this makes no
# difference.

include "lemma_game1FO'_game2FO'_o2h.qrhl".

# We show that game2FO'_goodbad_range is equivalent to
# game2FO'_goodbad_o2h_left' (which is like game1FO'_goodbad_o2h_left',
# except with decapsQuery2 instead of decapsQuery1).

# The only difference between game2FO'_goodbad_range and
# game2FO'_goodbad_o2h_left' is the use of decapsQuery2_range vs
# decapsQuery2. And the difference between these is that
# decapsQuery2_range distinguishes between the case that c is in the
# range of encT and returns Hq c or Hr c while decapsQuery2 always
# returns Hq c. We show that this is equivalent because Hq and Hr are
# both fresh and random *outside the range of encT*.

include "lemma_game2FO'_goodbad_range.qrhl".

# And now we do the game hops analogous to the above ones to reach
# game2FO'. (The following files are autogenerated from the above proofs.)

include "lemma_game2FO'_goodbad_o2h_left_class.qrhl".
include "lemma_game2FO'_goodbad_o2h_left'.qrhl".
include "lemma_game2FO'_o2h_concrete.qrhl".
include "lemma_game2FO'_goodbad_o2h_right.qrhl".
include "lemma_game2FO'_goodbad.qrhl".

# GRAPH: CLOSE("game1FO'_game2FO'", "game1FO'", "game2FO'", uses=["game1FO'_goodbad","game1FO'_goodbad_o2h_right","game1FO'_o2h_concrete","game1FO'_goodbad_o2h_left'","game1FO'_goodbad_o2h_left_class","game1FO'_goodbad_badpk","game1FO'_game2FO'_o2h","game2FO'_goodbad_range","game2FO'_goodbad_o2h_left_class","game2FO'_goodbad_o2h_left'","game2FO'_o2h_concrete","game2FO'_goodbad_o2h_right","game2FO'_goodbad"])

lemma game1FO'_game2FO':
 abs (Pr[b=1: game1FO'(rho)] - Pr[b=1: game2FO'(rho)]) <= 
   4 * sqrt( 4 * (1+real (qG+2*qH+qD+1))
                    * real (qG+2*qH+qD+1) * correctness params keygen enc dec msg_space)
   + correctness params keygen enc dec msg_space.

 isa subst game1FO'_goodbad.
 isa subst game1FO'_goodbad_o2h_right.
 rule abs_compute_step[OF game1FO'_o2h_concrete[THEN flip_abs]].
 isa subst game1FO'_goodbad_o2h_left'.
 isa subst game1FO'_goodbad_o2h_left_class.
 rule abs_compute_step[OF game1FO'_goodbad_badpk].
 isa subst game1FO'_game2FO'_o2h.
 isa subst game2FO'_goodbad_range.
 isa subst game2FO'_goodbad_o2h_left_class[symmetric].
 isa subst game2FO'_goodbad_o2h_left'[symmetric].
 rule abs_compute_step[OF game2FO'_o2h_concrete].
 isa subst game2FO'_goodbad_o2h_right[symmetric].
 isa subst game2FO'_goodbad[symmetric].
 rule abs_compute_end.
 simp.
qed.

