include "indcca_encFO_0.qrhl".
include "PRF_real.qrhl".
include "lemma_decapsQuery_decapsQueryPRF.qrhl".

# GRAPH: EQ("indcca_encFO_0_PRF_real", "indcca_encFO_0", "PRF_real", uses="decapsQuery_decapsQueryPRF")
lemma indcca_encFO_0_PRF_real: Pr[b=1:indcca_encFO_0(rho)] = Pr[b=1:PRF_real(rho)].
 byqrhl.
 inline indcca_encFO_0.
 inline PRF_real.
 inline Adv_PRF.

 conseq pre: Cla[classA1=classA2 & b1=b2 & cstar1=cstar2] âŠ“ âŸ¦quantA1âŸ§ â‰¡ğ”® âŸ¦quantA2âŸ§.
  simp!.

 local up.
 local remove right.
  simp!.

 conseq post: Cla[pk_of_sk sk2 = pk2 âˆ§ b1=b2 âˆ§ cstar1=cstar2 âˆ§ skfo1 = (sk2,prfk2)].
  simp!.

 equal mid quantA, Hin, Hout, Gin, Gout.
  simp!.

  conseq qrhl: decapsQuery_decapsQueryPRF.
   simp!.
   simp!.

 conseq post: â„­ğ”©ğ”[pk_of_sk sk2 = pk2 âˆ§ cstar1 = cstar2 âˆ§ skfo1 = (sk2, prfk2) âˆ§ classA1 = classA2 âˆ§ b1 = b2 âˆ§ G1 = G2 âˆ§ H1 = H2 âˆ§ Kstar1=Kstar2 âˆ§ in_pk1=in_pk2 & in_cstar1=in_cstar2] âŠ“ âŸ¦quantA1âŸ§ â‰¡ğ”® âŸ¦quantA2âŸ§.
  simp!.

 # in_pk, in_cstar
 wp 2 2.

 # ONLY PRIME: # Kstar
 # ONLY PRIME: rnd.
 # ONLY PRIME: simp keyspaceFO_def.

 # Kstar,cstar
 rnd.
 conseq post: â„­ğ”©ğ”[pk1=pk2 âˆ§ pk_of_sk sk2 = pk2 âˆ§ skfo1 = (sk2, prfk2) âˆ§ classA1 = classA2 âˆ§ b1 = b2 âˆ§ G1 = G2 âˆ§ H1 = H2 âˆ§ pk1=pk2 & cstar1=cstar2] âŠ“ âŸ¦quantA1âŸ§ â‰¡ğ”® âŸ¦quantA2âŸ§.
  simp!.

 # G,H to beginning
 swap right 2-3 1-1.

 # prfk, pk, sk
 squash right.
 
 rnd (pk,skfo), ((pk,sk),prfk) <- map_distr (Î»(pk,skfo). ((pk,skfo),((pk,fst skfo),snd skfo))) (keygenFO (G1,H2)).

 conseq post: â„­ğ”©ğ”[classA1 = classA2 âˆ§ b1 = b2 âˆ§ G1 = G2 âˆ§ H1 = H2 & cstar1=cstar2] âŠ“ âŸ¦quantA1âŸ§ â‰¡ğ”® âŸ¦quantA2âŸ§.
  simp ! keygenFO_keygenT pk_of_sk_keygenFO case_prod_beta.

 # G,H
 rnd.
 conseq post: â„­ğ”©ğ”[classA1 = classA2 âˆ§ b1 = b2 & cstar1=cstar2] âŠ“ âŸ¦quantA1âŸ§ â‰¡ğ”® âŸ¦quantA2âŸ§.
  simp !.

 skip.
 simp!.
qed.
