# Autogenerated file (by replacing game0FO -> game0FO', game1FO -> game1FO', etc. etc. in lemma_game1FO_goodbad.qrhl)

include "game1FO'_goodbad.qrhl".
include "game1FO'.qrhl".
include "lemma_ClassicalQueryG_queryG.qrhl".
include "lemma_queryH_invariant.qrhl".
include "lemma_decapsQuery1_1G.qrhl".

# GRAPH: EQ("game1FO'_goodbad","game1FO'","game1FO'_goodbad",uses="ClassicalQueryG_queryG")
lemma game1FO'_goodbad: Pr[b=1: game1FO'(rho)] = Pr[b=1: game1FO'_goodbad(rho)].
 byqrhl.

 inline game1FO'.
 inline game1FO'_goodbad.

 conseq post: Cla[b1=b2 & H1=mk_Hq Hq2 H02 G2 pk2 & G1=G2 & Hr1=Hr2 & cstar1=cstar2 & sk1=sk2 & pk1=pk2 & Hq1=Hq2].
  simp!.

 # Adv_INDCCA_encFO
 equal mid quantA, Hin, Hout, Gin, Gout.
  simp!.

  # queryH ~ queryH_Hq
  conseq post: ‚Ñ≠ùî©ùîû[H1 = mk_Hq Hq2 H02 G2 pk2] ‚äì ‚ü¶quantA1, Hin1, Hout1, Gin1, Gout1‚üß ‚â°ùîÆ ‚ü¶quantA2, Hin2, Hout2, Gin2, Gout2‚üß ‚äì ‚Ñ≠ùî©ùîû[classA1 = classA2 ‚àß c1 = c2 ‚àß K'1 = K'2 ‚àß b1 = b2 ‚àß in_pk1 = in_pk2 ‚àß in_cstar1 = in_cstar2 ‚àß Kstar1 = Kstar2 ‚àß G1 = G2 & Hr1=Hr2 & cstar1=cstar2 & sk1=sk2 & pk1=pk2 & Hq1=Hq2].
   simp!.
  conseq pre: ‚Ñ≠ùî©ùîû[H1 = mk_Hq Hq2 H02 G2 pk2] ‚äì ‚ü¶quantA1, Hin1, Hout1, Gin1, Gout1‚üß ‚â°ùîÆ ‚ü¶quantA2, Hin2, Hout2, Gin2, Gout2‚üß ‚äì ‚Ñ≠ùî©ùîû[classA1 = classA2 ‚àß c1 = c2 ‚àß K'1 = K'2 ‚àß b1 = b2 ‚àß in_pk1 = in_pk2 ‚àß in_cstar1 = in_cstar2 ‚àß Kstar1 = Kstar2 ‚àß G1 = G2 & Hr1=Hr2 & cstar1=cstar2 & sk1=sk2 & pk1=pk2 & Hq1=Hq2].
   simp!.
  frame.
   simp!.
  rule queryH_invariant.

  # decapsQuery1 ~ decapsQuery1_G(queryG)
  conseq post: Cla[G1=G2 & sk1=sk2 & c1=c2 & cstar1=cstar2 & K'1=K'2 & Hr1=Hr2 & pk1=pk2 & Hq1=Hq2] ‚äì ‚ü¶quantA1,Gin1,Gout1,Hin1,Hout1‚üß ‚â°ùîÆ ‚ü¶quantA2,Gin2,Gout2,Hin2,Hout2‚üß ‚äì Cla[in_cstar1=in_cstar2 & in_pk1=in_pk2 & classA1=classA2 & H1 = mk_Hq Hq2 H02 G2 pk2 & b1=b2 & Kstar1=Kstar2 & pk1=pk2 & Hq1=Hq2].
   isa! auto simp: reorder_qeq1.
  conseq pre: Cla[G1=G2 & sk1=sk2 & c1=c2 & cstar1=cstar2 & K'1=K'2 & Hr1=Hr2 & pk1=pk2 & Hq1=Hq2] ‚äì ‚ü¶quantA1,Gin1,Gout1,Hin1,Hout1‚üß ‚â°ùîÆ ‚ü¶quantA2,Gin2,Gout2,Hin2,Hout2‚üß ‚äì Cla[in_cstar1=in_cstar2 & in_pk1=in_pk2 & classA1=classA2 & H1 = mk_Hq Hq2 H02 G2 pk2 & b1=b2 & Kstar1=Kstar2 & pk1=pk2 & Hq1=Hq2].
   isa! auto simp: reorder_qeq1.
  frame.
   simp!.
  conseq qrhl (aux->Hin,Hout): decapsQuery1_1G.
   simp!.
   simp!.
   simp!.

 # End Adv_INDCCA_encFO


 conseq post: Cla[H1 = mk_Hq Hq2 H02 G2 pk2 ‚àß Hr1 = Hr2 ‚àß cstar1 = cstar2 ‚àß sk1 = sk2 ‚àß pk1 = pk2 ‚àß Hq1 = Hq2 ‚àß classA1 = classA2 ‚àß b1 = b2 ‚àß in_pk1 = in_pk2 ‚àß in_cstar1 = in_cstar2 ‚àß Kstar1 = Kstar2 ‚àß G1 = G2] ‚äì ‚ü¶quantA1‚üß ‚â°ùîÆ ‚ü¶quantA2‚üß.
  simp!.

 # gin2, gout2
 wp 0 2.
 conseq post: Cla[H1 = mk_Hq Hq2 H02 G2 pk2 ‚àß Hr1 = Hr2 ‚àß cstar1 = cstar2 ‚àß sk1 = sk2 ‚àß pk1 = pk2 ‚àß Hq1 = Hq2 ‚àß classA1 = classA2 ‚àß b1 = b2 ‚àß in_pk1 = in_pk2 ‚àß in_cstar1 = in_cstar2 ‚àß Kstar1 = Kstar2 ‚àß G1 = G2] ‚äì ‚ü¶quantA1‚üß ‚â°ùîÆ ‚ü¶quantA2‚üß.
  simp!.

 # in_cstar, in_pk
 wp 2 2.
 conseq post: Cla[H1 = mk_Hq Hq2 H02 G2 pk2 ‚àß Hr1 = Hr2 ‚àß cstar1 = cstar2 ‚àß sk1 = sk2 ‚àß pk1 = pk2 ‚àß Hq1 = Hq2 ‚àß classA1 = classA2 ‚àß b1 = b2 ‚àß Kstar1 = Kstar2 ‚àß G1 = G2] ‚äì ‚ü¶quantA1‚üß ‚â°ùîÆ ‚ü¶quantA2‚üß.
  simp!.

 # Kstar
 rnd.
 conseq post: Cla[H1 = mk_Hq Hq2 H02 G2 pk2 ‚àß Hr1 = Hr2 ‚àß cstar1 = cstar2 ‚àß sk1 = sk2 ‚àß pk1 = pk2 ‚àß Hq1 = Hq2 ‚àß classA1 = classA2 ‚àß b1 = b2 ‚àß G1 = G2] ‚äì ‚ü¶quantA1‚üß ‚â°ùîÆ ‚ü¶quantA2‚üß.
  simp!.

 # cstar
 wp 1 1.
 conseq post: Cla[mstar1=mstar2 & G1 mstar1=gout2 & H1=mk_Hq Hq2 H02 G2 pk2 ‚àß Hr1 = Hr2 ‚àß cstar1 = cstar2 ‚àß sk1 = sk2 ‚àß pk1 = pk2 ‚àß Hq1 = Hq2 ‚àß classA1 = classA2 ‚àß b1 = b2 ‚àß G1 = G2] ‚äì ‚ü¶quantA1‚üß ‚â°ùîÆ ‚ü¶quantA2‚üß.
  isa! auto simp: encrT_def.

 # skip ~ ClassicalQueryG(queryG)
 seq <-> 7 11: Cla[mstar1=mstar2 & mstar1=gin2 & H1=mk_Hq Hq2 H02 G2 pk2 ‚àß Hr1 = Hr2 ‚àß cstar1 = cstar2 ‚àß sk1 = sk2 ‚àß pk1 = pk2 ‚àß Hq1 = Hq2 ‚àß classA1 = classA2 ‚àß b1 = b2 ‚àß G1 = G2] ‚äì ‚ü¶quantA1‚üß ‚â°ùîÆ ‚ü¶quantA2‚üß.

 # Reorder to make clear to frame rule what to remove
 conseq pre: (‚ü¶quantA1‚üß ‚â°ùîÆ ‚ü¶quantA2‚üß) ‚äì Cla[mstar1=mstar2 & mstar1=gin2 & H1=mk_Hq Hq2 H02 G2 pk2 ‚àß Hr1 = Hr2 ‚àß cstar1 = cstar2 ‚àß sk1 = sk2 ‚àß pk1 = pk2 ‚àß Hq1 = Hq2 ‚àß classA1 = classA2 ‚àß b1 = b2 ‚àß G1 = G2].
  simp!.

 conseq post: (Cla[G2 gin2=gout2]  ‚äì ‚ü¶quantA1‚üß ‚â°ùîÆ ‚ü¶quantA2‚üß) ‚äì Cla[mstar1=mstar2 & mstar1=gin2 & H1=mk_Hq Hq2 H02 G2 pk2 ‚àß Hr1 = Hr2 ‚àß cstar1 = cstar2 ‚àß sk1 = sk2 ‚àß pk1 = pk2 ‚àß Hq1 = Hq2 ‚àß classA1 = classA2 ‚àß b1 = b2 ‚àß G1 = G2].
  simp!.

  frame.
   simp.

 conseq qrhl (aux->.): ClassicalQueryG_queryG.
  simp!.
  simp!.
  simp!.

 # End: skip ~ ClassicalQueryG(queryG)

 # mstar, gin2
 wp right.
 rnd.
 conseq post: Cla[H1 = mk_Hq Hq2 H02 G2 pk2 ‚àß Hr1 = Hr2 ‚àß cstar1 = cstar2 ‚àß sk1 = sk2 ‚àß pk1 = pk2 ‚àß Hq1 = Hq2 ‚àß classA1 = classA2 ‚àß b1 = b2 ‚àß G1 = G2] ‚äì ‚ü¶quantA1‚üß ‚â°ùîÆ ‚ü¶quantA2‚üß.
  simp!.

 # H
 wp left.
 conseq post: Cla[Hr1 = Hr2 ‚àß cstar1 = cstar2 ‚àß sk1 = sk2 ‚àß pk1 = pk2 ‚àß Hq1 = Hq2 ‚àß classA1 = classA2 ‚àß b1 = b2 ‚àß G1 = G2 & H01=H02] ‚äì ‚ü¶quantA1‚üß ‚â°ùîÆ ‚ü¶quantA2‚üß.
  simp!.

 # move G from beginning to here
 simp * keygenFO_anyG.
 swap left 2-5 1-1.

 # squash Ggood, Gbad, S, G
 squash right.
 squash right.
 squash right.

 # G
 simp * G_goodbad_squash_def[symmetric].
 rnd G, (Ggood,Gbad,S,G) <- map_distr (Œª(Ggood,Gbad,S,G). (G,(Ggood,Gbad,S,G))) (G_goodbad_squash pk2 sk2).

 conseq post: Cla[Hr1 = Hr2 ‚àß cstar1 = cstar2 ‚àß sk1 = sk2 ‚àß pk1 = pk2 ‚àß Hq1 = Hq2 ‚àß classA1 = classA2 ‚àß b1 = b2 ‚àß H01 = H02] ‚äì ‚ü¶quantA1‚üß ‚â°ùîÆ ‚ü¶quantA2‚üß.
  simp! case_prod_beta G_goodbad_squash_4th.

 # pk, sk, prfk
 squash right.
 rnd (pk,skfo), ((pk,sk),prfk) <- map_distr (Œª(pk,skfo). ((pk,skfo),((pk,fst skfo),snd skfo))) (keygenFO (G1,H2)).

 conseq post: Cla[Hr1 = Hr2 ‚àß cstar1 = cstar2 ‚àß Hq1 = Hq2 ‚àß classA1 = classA2 ‚àß b1 = b2 ‚àß H01 = H02] ‚äì ‚ü¶quantA1‚üß ‚â°ùîÆ ‚ü¶quantA2‚üß.
  simp ! keygenFO_keygenT pk_of_sk_keygenFO case_prod_beta keygenT_def.

 # Hr, H0, Hq
 rnd.
 simp.
 rnd.
 simp.
 rnd.
 skip.

 simp!.

qed.
